# Module 08 - High Level Networking

### 1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?

Perbedaan utama dari unary, server streaming, dan bi-directional streaming adalah pada bagaimana request dan response diproses. Pada metode unary, client mengirimkan satu request dan server meresponse dengan satu response, seperti pada implementasi `MyPaymentService` yang menerima `PaymentRequest` dan mengembalikan `PaymentResponse`. Metode server streaming memungkinkan client mengirim satu request namun server dapat mengirimkan beberapa response secara berkelanjutan, seperti pada implementasi `MyTransactionService` yang mengembalikan stream `TransactionResponse`. Sedangkan pada bi-directional streaming, client dan server keduanya dapat mengirim dan menerima stream pesan secara bersamaan dan sendiri-sendiri, seperti pada `MyChatService`. Metode unary cocok untuk operasi sederhana seperti autentikasi. Server streaming cocok untuk situasi di mana server perlu mengirimkan data besar seperti riwayat transaksi. Bi-directional streaming cocok untuk aplikasi yang membutuhkan komunikasi real-time seperti chat, di mana kedua pihak aktif berkomunikasi tanpa harus menunggu response dari pihak lain.

### 2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?

Dalam mengimplementasikan layanan gRPC di Rust, beberapa pertimbangan keamanan yang harus diperhatikan adalah autentikasi, otorisasi, dan enkripsi data. Untuk autentikasi, developer perlu memastikan bahwa setiap request yang masuk telah diverifikasi, misalnya dengan menggunakan JWT token atau OAuth yang divalidasi di setiap request. Untuk otorisasi, perlu memastikan bahwa client yang terautentikasi memiliki hak akses yang sesuai untuk resource atau operasi yang diminta, seperti menerapkan RBAC. Sementara untuk enkripsi data, implementasi gRPC sebaiknya menggunakan TLS/SSL untuk mengamankan komunikasi antara client dan server. Keamanan tambahan seperti validasi input untuk mencegah injection attack, pembatasan rate request untuk mencegah DDoS, dan activity log juga penting. Implementasi keamanan ini di Rust sebenarnya lebih mudah karena ada fitur ownership dan borrowing system yang sudah membantu mencegah berbagai jenis ancaman keamanan.

### 3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?

Potensi tantangan dalam menangani bi-directional streaming di Rust gRPC salah satunya adalah pengelolaan concurrency dan state. Dalam aplikasi chat, tantangan utama adalah mencegah race condition saat mengelola pesan yang masuk dan keluar secara bersamaan. Kode dalam service chat harus menangani banyak koneksi client secara bersamaan sambil menjaga konsistensi data. Menjaga koneksi yang stabil juga merupakan tantangan, seperti saat menangani putusnya koneksi dan reconnect dari client. Pengelolaan memori yang efisien juga penting karena stream yang berjalan lama dapat mengakumulasi alokasi memori jika tidak ditangani dengan tepat. Dalam implementasi chat yang efektif, perlu menambahkan mekanisme heartbeat untuk mendeteksi koneksi terputus, mengelola backpressure ketika client tidak dapat memproses pesan dengan cepat, dan memastikan bahwa resource dibersihkan dengan tepat ketika koneksi berakhir.

### 4. What are the advantages and disadvantages of using the `tokio_stream::wrappers::ReceiverStream` for streaming responses in Rust gRPC services?

Kelebihan dalam menggunakan `tokio_stream::wrappers::ReceiverStream` untuk streaming response adalah penyediaan high level abstraction yang menyederhanakan implementasi streaming di gRPC Rust. `ReceiverStream` memungkinkan kita mengubah channel `Tokio` menjadi `Stream` yang kompatibel dengan API gRPC, sehingga kita bisa memanfaatkan fitur concurrency `Tokio` seperti yang terlihat dalam implementasi `MyTransactionService` dan `MyChatService` di tutorial. Library ini juga menangani backpressure secara otomatis, yang berarti server tidak akan mengirim pesan lebih cepat daripada kemampuan client untuk memprosesnya. `ReceiverStream` juga terintegrasi dengan baik dalam ecosystem asynchronous Rust. 

Kekurangan penggunaan `ReceiverStream` adalah menambahnya kompleksitas kode dengan pemrograman asynchronous, yang dapat membuat debugging menjadi lebih sulit. Overhead performance juga bisa menjadi masalah dibandingkan dengan implementasi manual yang lebih dioptimalkan. Penggunaan `ReceiverStream` juga membuat ketergantungan pada ecosystem `Tokio`, yang berarti developer harus memahami model programming asynchronous dan runtime `Tokio`.

### 5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?

Layanan-layanan seperti `PaymentService`, `TransactionService`, dan `ChatService` dapat dipisahkan ke dalam modul terpisah dan tidak digabungkan dalam satu file. Implementasi utama sebaiknya dipisahkan dari code handler gRPC, sehingga implementasi tersebut dapat digunakan kembali atau diuji secara tersendiri. Penggunaan trait untuk mendefinisikan interface dapat meningkatkan abstraction dan memungkinkan implementasi yang berbeda-beda. Middleware atau interceptor dapat diimplementasikan untuk menangani aspek seperti logging, autentikasi, dan monitoring. Mengorganisasi kode ke dalam direktori yang terstruktur dengan jelas, seperti pemisahan antara definisi proto, implementasi layanan, dan kode util akan meningkatkan navigasi dan maintainability. Selain itu, memisahkan konfigurasi dari implementasi memudahkan penyesuaian konfigurasi tanpa mengubah kode. Menerapkan dependency injection juga dapat membantu menulis kode yang lebih testable.

### 6. In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?

Dalam implementasi `MyPaymentService` yang lebih kompleks, perlu ditambahkan beberapa langkah pemrosesan tambahan. Validasi input yang lebih ketat perlu dilakukan, seperti memastikan jumlah pembayaran valid, mata uang yang dapat digunakan, dan identitas pengguna terverifikasi. Koneksi dengan sistem pembayaran external atau payment gateway perlu diimplementasikan, yang mungkin melibatkan API calls ke layanan third party. Mekanisme transaksi atomic juga penting untuk memastikan konsistensi data, misalnya menggunakan two phase commit jika melibatkan beberapa sumber data. Penanganan error yang lebih robust diperlukan, seperti adanya implementasi logging komprehensif untuk audit. Implementasi multi-threading atau model asynchronous juga akan membantu menangani banyak request pembayaran secara bersamaan dengan efisien. Sistem notifikasi untuk mengonfirmasi status pembayaran ke pengguna juga penting, mungkin menggunakan webhook atau saluran notifikasi lain. Regulasi keamanan pembayaran seperti PCI-DSS juga perlu dipertimbangkan, yang mungkin memerlukan enkripsi data khusus dan mekanisme keamanan tambahan.

### 7.  What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?

Dengan mengadopsi gRPC, arsitektur sistem terdistribusi mengalami beberapa perubahan besar. gRPC mendorong penggunaan service contract yang terdefinisi dengan jelas melalui Protocol Buffers, yang memungkinkan komunikasi yang lebih terstruktur antar komponen sistem. Hal ini meningkatkan konsistensi data type dan operasi di seluruh layanan, dan menyederhanakan integrasi antar layanan yang mungkin ditulis dalam bahasa pemrograman berbeda. Performa sistem juga meningkat karena gRPC menggunakan HTTP/2 sebagai transport protocol dan serialization binary yang efisien, mengurangi overhead jaringan dan meningkatkan throughput. Dukungan gRPC untuk berbagai pola komunikasi, seperti bi-directional streaming memungkinkan design sistem yang lebih fleksibel. Tetapi, interoperability bisa menjadi masalah saat berinteraksi dengan sistem yang tidak mendukung gRPC atau lebih terbiasa dengan REST API. Kompleksitas development juga meningkat karena developer harus memahami Protocol Buffers dan konsep streaming. Dari sisi infrastruktur, load balancing dan monitoring untuk gRPC memerlukan pendekatan khusus dibandingkan dengan HTTP biasanya.

### 8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?

Keuntungan menggunakan HTTP/2 dibanding HTTP/1.1 ada pada beberapa fitur utamanya. HTTP/2 memungkinkan banyak request dan response diproses secara bersamaan dalam satu koneksi TCP, sehingga tidak terjadi "head-of-line blocking" seperti di HTTP/1.1. Header compression di HTTP/2 mengurangi overhead jaringan, yang sangat membantu dalam komunikasi microservice yang sering menggunakan banyak metadata. Format binary HTTP/2 lebih efisien dalam parsing dan processing dibandingkan format text HTTP/1.1. Selain itu, fitur server push memungkinkan server mengirimkan resource ke client lebih awal. HTTP/2 juga memiliki beberapa kelemahan, seperti implementasi yang lebih kompleks, ketergantungan pada satu koneksi TCP (jika koneksi terputus, semua stream terdampak), dan terbatasnya kompatibilitas dengan proxy lama. Jika dibandingkan dengan WebSocket, HTTP/2 menawarkan multiplexing dan header compression yang lebih baik, tetapi WebSocket memiliki overhead lebih rendah untuk komunikasi yang sering terjadi, sehingga lebih cocok untuk aplikasi real-time dengan pertukaran pesan cepat.

### 9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?

Model request-response dari REST API berbeda besar dengan kemampuan bi-directional streaming gRPC dalam konteks komunikasi real-time. Dalam REST, client harus menginisiasi setiap interaksi dengan mengirimkan request, dan server hanya dapat meresponse ketika ada request masuk. Ini menciptakan pola komunikasi yang uni-directional dan synchronous, di mana server tidak dapat mengirim data ke client tanpa diminta terlebih dahulu. Untuk aplikasi real-time dengan REST, client biasanya harus menggunakan polling atau metode seperti long polling untuk mendapatkan update terbaru. Sebaliknya, gRPC dengan bi-directional streaming memungkinkan client dan server untuk mengirim pesan secara tersendiri setelah koneksi dibuat, tanpa harus menunggu permintaan dari pihak lain. Ini memungkinkan komunikasi full-duplex yang efisien, seperti yang diimplementasikan pada `MyChatService` pada tutorial. Model gRPC juga lebih efisien dalam penggunaan resource jaringan karena koneksi dibuka sekali dan digunakan untuk banyak pesan, tidak seperti REST yang mungkin memerlukan pembukaan dan penutupan koneksi untuk setiap interaksi. gRPC menawarkan latency lebih rendah dan throughput lebih tinggi untuk aplikasi real-time seperti chat, monitoring, atau kolaborasi real-time.

### 10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?

Pendekatan berbasis skema gRPC dengan Protocol Buffers memiliki implikasi yang berbeda dibandingkan dengan sifat fleksibel tanpa skema JSON pada REST API. Dengan Protocol Buffers, struktur data, data types, dan interface didefinisikan secara eksplisit dalam file .proto, yang kemudian digunakan untuk menghasilkan kode di berbagai bahasa. Ini menciptakan contract yang jelas antara client dan server, mengurangi resiko incompatibility dan mempermudah deteksi error pada waktu kompilasi. Format binary Protocol Buffers juga lebih efisien dalam hal ukuran payload dan kecepatan serialization atau deserialization dibandingkan JSON. Namun, pendekatan ini kurang fleksibel karena perubahan pada struktur data memerlukan pembaruan skema dan mungkin diperlukan recompile. Sebaliknya, JSON dalam REST API bersifat lebih fleksibel karena tidak memerlukan definisi skema formal. Field baru dapat ditambahkan atau diubah tanpa mempengaruhi kompatibilitas, yang mempercepat iterasi development. JSON juga lebih human-readable, yang memudahkan debugging. Namun, fleksibilitas ini menyebabkan tidak adanya validasi data type secara otomatis, resiko error runtime lebih tinggi, dan overhead parsing yang lebih besar. Pilihan antara keduanya bergantung pada prioritas, jika konsistensi, performa, dan keamanan tipe adalah prioritas, gRPC dengan Protocol Buffers lebih baik. Jika fleksibilitas, kemudahan development, dan kompatibilitas luas diutamakan, REST API dengan JSON lebih cocok.